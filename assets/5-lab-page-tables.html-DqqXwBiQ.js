import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o,c as l,a as n,d as a,b as t,e as s}from"./app-6tGj9yd3.js";const i="/assets/image-20240509111735902-MYzY1ScM.png",r={},u=s(`<h1 id="lab-3-page-tables" tabindex="-1"><a class="header-anchor" href="#lab-3-page-tables"><span>Lab 3: page tables</span></a></h1><p>在这个实验中，你将探索页面表并修改它们以加速特定的系统调用，并检测哪些页面已被访问。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>在你开始编码之前，请阅读 xv6 书的第三章以及相关文件：</p><ul><li>kernel/memlayout.h，其中包含内存布局的信息。</li><li>kernel/vm.c，其中包含大部分虚拟内存（VM）代码。</li><li>kernel/kalloc.c，其中包含分配和释放物理内存的代码。 同时，参考 RISC-V 特权架构手册可能也会有所帮助。</li></ul></div><p>要开始实验，请切换到 pgtbl 分支：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> fetch 
$ <span class="token function">git</span> checkout pgtbl 
$ <span class="token function">make</span> clean
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),d={id:"speed-up-system-calls-easy",tabindex:"-1"},k={class:"header-anchor",href:"#speed-up-system-calls-easy"},m={href:"https://pdos.csail.mit.edu/6.S081/2023/labs/guidance.html",target:"_blank",rel:"noopener noreferrer"},v=s('<h3 id="实验要求翻译" tabindex="-1"><a class="header-anchor" href="#实验要求翻译"><span>实验要求翻译</span></a></h3><p>一些操作系统（例如Linux）通过在用户空间和内核之间共享一块只读空间来加速某些特定的系统调用。这消除了执行这些系统调用时需要内核交叉的需求。为了帮助你学习如何将映射插入到页面表中，你的第一个任务是为 xv6 中的 getpid() 系统调用实现这种优化。</p><div class="hint-container important"><p class="hint-container-title">重要</p><p>在每个进程创建时，在 USYSCALL（在 memlayout.h 中定义的一个虚拟地址）处映射一个只读页面。在这个页面的开头，存储一个 struct usyscall（也在 memlayout.h 中定义），并将其初始化为存储当前进程的 PID。在这个实验中，ugetpid() 已经在用户空间中提供，并将自动使用 USYSCALL 映射。如果运行 pgtbltest 时 ugetpid 测试用例通过，则你将获得此实验的完整学分。</p></div><p>一些提示：</p><ul><li>你可以在 kernel/proc.c 中的 proc_pagetable() 中执行映射。</li><li>选择允许用户空间只读取页面的权限位。</li><li>你可能会发现 mappages() 是一个有用的实用程序。</li><li>不要忘记在 allocproc() 中分配和初始化页面。 确保在 freeproc() 中释放页面。</li></ul><div class="hint-container important"><p class="hint-container-title">重要</p><p>ChatGPT 你还可以使用共享页面加速哪些其他 xv6 系统调用？请解释一下。</p></div><h3 id="实验操作" tabindex="-1"><a class="header-anchor" href="#实验操作"><span>实验操作</span></a></h3><p>进行实操前需要回答几个问题：</p><ol><li>usyscall这个结构体需要存在哪里</li><li>需要建立虚拟地址与物理地址的映射，物理地址要怎么获取？</li><li>初始化与释放需要做什么？</li></ol><h4 id="step1" tabindex="-1"><a class="header-anchor" href="#step1"><span>step1</span></a></h4><p>在 <code>proc.h</code>中声明一个<code>usyscall</code>结构体，用于存放共享页面。</p><figure><img src="'+i+`" alt="image-20240509111735902" tabindex="0" loading="lazy"><figcaption>image-20240509111735902</figcaption></figure><h4 id="step2" tabindex="-1"><a class="header-anchor" href="#step2"><span>step2</span></a></h4><p>在(<code>kernel/proc.c</code>)中修改<code>allocproc</code>方法，仿照给<code>trapframe</code>为<code>p-&gt;usyscall</code> 分配具体的物理地址，并且将进程的pid 保存到这个结构体之中。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>  <span class="token comment">// Allocate a usyscall page</span>
  <span class="token comment">//这里的地址其实就是一个物理地址，是需要在用户页表中与逻辑地址进行映射的的地址</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>usyscall <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  p<span class="token operator">-&gt;</span>usyscall<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> p<span class="token operator">-&gt;</span>pid<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在 xv6 中，内核通过 <code>kalloc()</code> 来分配物理内存页面。</p></blockquote><h4 id="step3" tabindex="-1"><a class="header-anchor" href="#step3"><span>step3</span></a></h4><p>在<code>(kernel/proc.c)</code>中修改<code>proc_pagetable</code>方法，仿照给<code>trapframe</code>新增映射关系，这里实验有要求许用户空间只读取页面的权限位，所以使用权限<code>PTE_R</code>与<code>PTE_U</code></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span>USYSCALL<span class="token punctuation">,</span>PGSIZE<span class="token punctuation">,</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>usyscall<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="step4" tabindex="-1"><a class="header-anchor" href="#step4"><span>step4</span></a></h4><p>在(<code>kernel/proc.c</code>)中修改<code>freeproc</code>与<code>proc_freepagetable</code>，在进程释放的时候将对应内存释放掉。</p><p><code>freeproc</code>中增加</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">freeproc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">//新增代码 begin</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>usyscall<span class="token punctuation">)</span>
    <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-&gt;</span>usyscall<span class="token punctuation">)</span><span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>usyscall <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">//新增代码 end</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>trapframe<span class="token punctuation">)</span>
    <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-&gt;</span>trapframe<span class="token punctuation">)</span><span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>trapframe <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">)</span>
    <span class="token function">proc_freepagetable</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>proc_freepagetable</code>中增加</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">void</span>
<span class="token function">proc_freepagetable</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">//为什么这里不释放会导致panic: freewalk: leaf</span>
  <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//新增行</span>
  <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAPFRAME<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><p>由step2可以看出内核中其实是可以直接进行物理内存的操作，包括分配内存，和写入数据。那么这里就有个人有个疑问就是，逻辑地址的重要性到现在体现的还不是很明显，这个问题还有待回答。</p><p>还有就是step4中为什么不释放USYSCALL所在内存会导致panic？freeproc这个方法在进程的生命周期的哪个阶段会被调用，一个进程的所有内存没被全部释放掉会导致什么问题？</p><p>以上疑问有待解决。</p>`,29),b={id:"print-a-page-table-easy",tabindex:"-1"},g={class:"header-anchor",href:"#print-a-page-table-easy"},h={href:"https://pdos.csail.mit.edu/6.S081/2022/labs/guidance.html",target:"_blank",rel:"noopener noreferrer"},f=s(`<h4 id="实验要求翻译-1" tabindex="-1"><a class="header-anchor" href="#实验要求翻译-1"><span>实验要求翻译</span></a></h4><p>为了帮助你形象化 RISC-V 的页表，并可能帮助未来的调试工作，你的第二个任务是编写一个函数，打印页表的内容。</p><div class="hint-container important"><p class="hint-container-title">重要</p><p>定义一个名为 <code>vmprint()</code> 的函数。它应该接受一个 <code>pagetable_t</code> 参数，并以下述格式打印该页表。在 <code>exec.c</code> 中的 <code>return argc</code> 之前插入 <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，以打印第一个进程的页表。如果通过 <code>make grade</code> 中的页表项打印测试，则你将获得此部分实验的全部学分。</p></div><p>当你启动xv6的时候它应该输出以下内容，描述在第一个进程刚刚完成执行 <code>init</code> 的 <code>exec()</code> 时的页表。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>page table 0x0000000087f6b000
 ..0: pte 0x0000000021fd9c01 pa 0x0000000087f67000
 .. ..0: pte 0x0000000021fd9801 pa 0x0000000087f66000
 .. .. ..0: pte 0x0000000021fda01b pa 0x0000000087f68000
 .. .. ..1: pte 0x0000000021fd9417 pa 0x0000000087f65000
 .. .. ..2: pte 0x0000000021fd9007 pa 0x0000000087f64000
 .. .. ..3: pte 0x0000000021fd8c17 pa 0x0000000087f63000
 ..255: pte 0x0000000021fda801 pa 0x0000000087f6a000
 .. ..511: pte 0x0000000021fda401 pa 0x0000000087f69000
 .. .. ..509: pte 0x0000000021fdcc13 pa 0x0000000087f73000
 .. .. ..510: pte 0x0000000021fdd007 pa 0x0000000087f74000
 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
init: starting sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一行显示了 <code>vmprint</code> 的参数。之后每个PTE（页表项）都有一行，包括指向页表树中更深层的PTE。每行的页表项使用几个“..”缩进用于表明其在页表树中的深度。每行PTE显示PTE在其所在页表中的索引，比特位，以及从页表项中提取的物理地址。不要打印无效的页表项。在上面的例子中顶层页表页对条目 0 和 255 进行了映射。下一级对于条目 0 仅映射了索引 0，而该索引 0 的底层页表页有条目 0、1 和 2 进行了映射。</p><p>你的代码可能会显示与上面不同的物理地址。但是这些条目和虚拟地址应该是相同的。</p><p>一些提示：</p><ul><li>你可以在 <code>kernel/vm.c</code>使用 <code>vmprint()</code></li><li>使用文件 <code>kernel/riscv.h</code> 末尾的宏。</li><li>方法<code>freewalk</code>也许会有启发。</li><li>在 <code>kernel/defs.h</code> 中定义 <code>vmprint</code> 的原型，这样你就可以从 <code>exec.c</code> 中调用它。</li><li>在 <code>printf</code> 调用中使用 <code>%p</code> 来以完整的 64 位十六进制形式打印页表项和地址，就像示例中所示的一样</li></ul><div class="hint-container important"><p class="hint-container-title">重要</p><p>解释 <code>vmprint</code> 的输出与文本中的图 3-4 的关系。页面 0 包含什么？页面 2 中有什么？在用户模式下，进程能读/写页面 1 映射的内存吗？倒数第三页包含什么？</p></div>`,10);function y(x,_){const e=c("ExternalLinkIcon");return o(),l("div",null,[u,n("h2",d,[n("a",k,[n("span",null,[a("Speed up system calls ("),n("a",m,[a("easy"),t(e)]),a(")")])])]),v,n("h2",b,[n("a",g,[n("span",null,[a("Print a page table ("),n("a",h,[a("easy"),t(e)]),a(")")])])]),f])}const L=p(r,[["render",y],["__file","5-lab-page-tables.html.vue"]]),P=JSON.parse(`{"path":"/cs-basics/os/6.S081/labs/5-lab-page-tables.html","title":"Lab 3: page tables","lang":"zh-CN","frontmatter":{"icon":"code-bold","date":"2024-05-08T00:00:00.000Z","category":["操作系统"],"tag":["MIT","XV6","riscv","C"],"description":"Lab 3: page tables 在这个实验中，你将探索页面表并修改它们以加速特定的系统调用，并检测哪些页面已被访问。 注意 在你开始编码之前，请阅读 xv6 书的第三章以及相关文件： kernel/memlayout.h，其中包含内存布局的信息。 kernel/vm.c，其中包含大部分虚拟内存（VM）代码。 kernel/kalloc.c，其中包...","head":[["meta",{"property":"og:url","content":"https://passerbyjia.github.io/cs-basics/os/6.S081/labs/5-lab-page-tables.html"}],["meta",{"property":"og:site_name","content":"Plus's NoteBook"}],["meta",{"property":"og:title","content":"Lab 3: page tables"}],["meta",{"property":"og:description","content":"Lab 3: page tables 在这个实验中，你将探索页面表并修改它们以加速特定的系统调用，并检测哪些页面已被访问。 注意 在你开始编码之前，请阅读 xv6 书的第三章以及相关文件： kernel/memlayout.h，其中包含内存布局的信息。 kernel/vm.c，其中包含大部分虚拟内存（VM）代码。 kernel/kalloc.c，其中包..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-09T13:34:02.000Z"}],["meta",{"property":"article:author","content":"Plus"}],["meta",{"property":"article:tag","content":"MIT"}],["meta",{"property":"article:tag","content":"XV6"}],["meta",{"property":"article:tag","content":"riscv"}],["meta",{"property":"article:tag","content":"C"}],["meta",{"property":"article:published_time","content":"2024-05-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-09T13:34:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Lab 3: page tables\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-08T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-09T13:34:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Plus\\",\\"url\\":\\"https://passerbyjia.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Speed up system calls (easy)","slug":"speed-up-system-calls-easy","link":"#speed-up-system-calls-easy","children":[{"level":3,"title":"实验要求翻译","slug":"实验要求翻译","link":"#实验要求翻译","children":[]},{"level":3,"title":"实验操作","slug":"实验操作","link":"#实验操作","children":[]}]},{"level":2,"title":"Print a page table (easy)","slug":"print-a-page-table-easy","link":"#print-a-page-table-easy","children":[]}],"git":{"createdTime":1715185891000,"updatedTime":1715261642000,"contributors":[{"name":"JH","email":"jh_personal@163.com","commits":6}]},"readingTime":{"minutes":5.64,"words":1692},"filePathRelative":"cs-basics/os/6.S081/labs/5-lab-page-tables.md","localizedDate":"2024年5月8日","excerpt":"\\n<p>在这个实验中，你将探索页面表并修改它们以加速特定的系统调用，并检测哪些页面已被访问。</p>\\n<div class=\\"hint-container warning\\">\\n<p class=\\"hint-container-title\\">注意</p>\\n<p>在你开始编码之前，请阅读 xv6 书的第三章以及相关文件：</p>\\n<ul>\\n<li>kernel/memlayout.h，其中包含内存布局的信息。</li>\\n<li>kernel/vm.c，其中包含大部分虚拟内存（VM）代码。</li>\\n<li>kernel/kalloc.c，其中包含分配和释放物理内存的代码。 同时，参考 RISC-V 特权架构手册可能也会有所帮助。</li>\\n</ul>\\n</div>","autoDesc":true}`);export{L as comp,P as data};
